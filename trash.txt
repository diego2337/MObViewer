from main.js, function app.post('/upload', function(req, res):

// once all the files have been uploaded, send a response to the client
// form.on('end', function() {
//   function waitForFile() {
//     if(typeof form.openedFiles[0] !== undefined) {
//       // console.log("form: ");
//       // console.log(form);
//       // console.log("file name: " + form.openedFiles[0].name);
//       res.end(form.uploadDir + "/" + form.openedFiles[0].name);
//     }
//     else {
//       setTimeout(waitForFile, 500);
//     }
//   }
//   waitForFile();
//   // res.end('success');
// });


from newIndex.html, starting at line 154

<div class="mdl-grid mdl-cell mdl-cell--8-col demo-cards mdl-shadow--2dp mdl-color--white relative-div">
  <!-- <h4 class="mdl-card__title">Graph</h4> -->
  <h4 class="mdl-card__title mdl-layout__header-row relative-div">Graph</h4>
  <!-- <div id="WebGL" class="demo-cards mdl-shadow--2dp mdl-color--white mdl-cell mdl-cell--8-col relative-div"> -->
  <div id="WebGL" class="mdl-grid mdl-cell mdl-cell--12-col">
    <!-- <div class="mdl-cell mdl-cell--12-col"></div> -->
    <div class="mdl-grid mdl-cell mdl-cell--12-col">
      <!-- <div class="mdl-cell mdl-layout-spacer"></div> -->
      <div class="mdl-cell"> </div>
      <!-- <div class="mdl-cell mdl-cell--12-col mdl-layout-spacer"></div> -->
      <div id="progressBar" class="hidden-visibility mdl-progress mdl-js-progress mdl-progress__indeterminate">
        <h6 >Loading graph...</h6>
      </div>
      <div class="mdl-cell"> </div>
      <!-- <div class="mdl-cell mdl-layout-spacer"></div> -->
      <!-- <div class="mdl-cell mdl-cell--12-col mdl-layout-spacer"></div> -->
    </div>
    <!-- <div class="mdl-cell mdl-cell--12-col"></div> -->
  </div>
  <div class="mdl-cell mdl-cell--bottom mdl-layout__header-row">
    <!-- Title -->
    <span class="mdl-layout-title">Zooming and panning</span>
    <!-- Add spacer, to align navigation to the right -->
    <div class="mdl-layout-spacer"></div>
    <!-- Add zooming and panning -->
    <button class="mdl-cell--middle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" id="panLeft">
      <i class="material-icons">add</i>
    </button>
  </div>
</div>

from threeGraph.js, function build(data, layout):

//console.log(graph);

/* Checking for WebGL compatibility */
// if(Detector.webgl)
// {
//     console.log("WebGL supported");
//     renderer = new THREE.WebGLRenderer({antialias:true});
//
//     // If its not supported, instantiate the canvas renderer to support all non WebGL
//     // browsers
// }
// else
// {
//     console.log("WebGL not supported");
//     renderer = new THREE.CanvasRenderer();
// }

/* Create lights to associate with scene */
// var lights = [];
// lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
// lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
// lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );
//
// lights[ 0 ].position.set( 0, 2, 0 );
// lights[ 1 ].position.set( 1, 2, 1 );
// lights[ 2 ].position.set( - 1, - 2, - 1 );
//
// scene.add( lights[ 0 ] );
// scene.add( lights[ 1 ] );
// scene.add( lights[ 2 ] );

/* Deprecated listeners - orbitControls taking care of zooming and panning */
// document.addEventListener('click', function(evt){eventHandler.clickEvent(evt, camera);}, false);
// document.addEventListener('mousedown', function(evt){eventHandler.mouseDownEvent(evt, camera);}, false);
// document.addEventListener('wheel', function(evt){eventHandler.wheelEvent(evt, camera); evt.preventDefault();}, false);


from threeGraph.js, function animate():

// var fs = new FileReader();
/* Converting passed textarea input to JSON */
// var jason = JSON.parse($.trim($("textarea").val()));
// fs.onload = (function(data){
// })(path);

from main.js, function app.post('/upload', function(req, res):

// nodeCmd.run('mkdir -p uploads/' + file.name.split(".")[0]);
// nodeCmd.run('python mob/gmlToJson2.py uploads' + folderChar + file.name + ' uploads' + folderChar + file.name.split(".")[0] + '/' + file.name.split(".")[0] + '.json');
// graphSize = JSON.parse(data).graphInfo[0].vlayer.split(" ");
// if(req.body.firstSet) {
//   pyCoarsening = pyCoarsening + " " + req.body.coarsening + " 0";
//   pyName = pyName + "l" + req.body.coarsening.split(".").join("") + "r0";
// } else {
//   pyCoarsening = pyCoarsening + " 0 " + req.body.coarsening;
//   pyName = pyName + "l0" + "r" + req.body.coarsening.split(".").join("");
// }

from main.js, function app.post('/switch', function(req, res):

// /* Switch currrent layout */
// switch(req.body.layout)
// {
//   /* Horizontal layout; change to vertical */
//   case 2:
//
//   break;
//   /* Vertical layout; change to horizontal */
//   case 3:
//
//   break;
//   default:
//   break;
// }

from eventHandler.js:

/**
 * Handles clicking in scene
 * params:
 *    - evt: event dispatcher;
 *    - camera: camera used in three.js scene visualization.
 */
// EventHandler.prototype.clickEvent = function(evt, camera)
// {
//     console.log(camera);
// }

/**
 * Handles dragging, which triggers panning
 * params:
 *    - evt: event dispatcher;
 *    - camera: camera used in three.js scene visualization.
 */
EventHandler.prototype.dragEvent = function(evt, camera)
{
    console.log("dragging");
}

/**
 * Handles mouse wheel. If mouse is scrolled up, zoom in; otherwise zoom out
 * params:
 *    - evt: event dispatcher;
 *    - camera: camera used in three.js scene visualization.
 */
EventHandler.prototype.wheelEvent = function (evt, camera)
{
    /* Check either scroll up or scroll down */
    if(evt.deltaY > 0)
    {
        /* Down scroll - decrease zoom */
        // console.log("Down scroll");
        if(camera.zoom - 4 > 0)
        {
            camera.zoom = camera.zoom - 4;
            camera.updateProjectionMatrix();
        }
    }
    else
    {
        /* Up scroll - increase zoom */
        // console.log("Up scroll");
        camera.zoom = camera.zoom + 4;
        camera.updateProjectionMatrix();
    }
}

/**
 * Handles mouse down. Initial function for dragging and camera panning
 * params:
 *    - evt: event dispatcher;
 *    - camera: camera used in three.js scene visualization.
 */
EventHandler.prototype.mouseDownEvent = function (evt, camera)
{
    /* Adapted from https://stackoverflow.com/questions/9047600/how-to-determine-the-direction-on-onmousemove-event */
    /* Object to store last position of cursor */
    var lastPosition = {};
    var cam = camera;
    document.onmouseup = function(evt){ document.onmousemove = null; document.onmouseup = null; }
    document.onmousemove = function(evt)
    {
        /* Compare with lastPosition */
        if(typeof(lastPosition.x) != undefined)
        {
            /* Get delta */
            var deltaX = lastPosition.x - evt.clientX;
            var deltaY = lastPosition.y - evt.clientY;
            /* Check direction */
            if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 0)
            {
                /* Left */
                cam.position.x = cam.position.x + 2.5;
            }
            else if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX < 0)
            {
                /* Right */
                cam.position.x = cam.position.x - 2.5;
            }
            else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 0)
            {
                /* Up */
                cam.position.y = cam.position.y - 2.5;
            }
            else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY < 0)
            {
                /* Down */
                cam.position.y = cam.position.y + 2.5;
            }
        }
        /* Update last position */
        lastPosition = {
            x : evt.clientX,
            y : evt.clientY
        };
    }
}

from main.js:

// app.engine('html', require('ejs').renderFile);

in function app.post('/upload', function(req, res)):
// form.multiples = false;
// parse the incoming request containing the form data
form.parse(req, function(err, fields, files){
});

in function app.get('/', function(req, res)):
// res.sendFile(path.join(__dirname, 'public/views/index.html'));

from slider.js:

/* Apply changes for second layer coarsening */
$('#multilevelCoarsener2').on('change', function(){
  document.getElementById("output2").innerHTML = $('#multilevelCoarsener2')[0].value;
  /* Perform an AJAX request to server */
  $.ajax({
    url: '/slide',
    type: 'POST',
    data: {coarsening: $('#multilevelCoarsener')[0].value, coarseningSecondSet: $('#multilevelCoarsener2')[0].value, firstSet: false},
    // data: JSON.parse($('#multilevelCoarsener')[0].value),
    success: graphUpdate,
    xhr: loadGraph
  });
});

/**
  * Change min and max values for input type range element in HTML page.
  * @public
  * @param {Object} data .json graph uploaded to server-side
  */
function changeMinAndMaxValues(data)
{
  console.log("changeMinAndMaxFunction");
  var d = JSON.parse(data);
  var numberOfNodes1 = d.graphInfo[0].vlayer.split(" ");
  $('#multilevelCoarsener').prop({
    'min': 1,
    'max': numberOfNodes1[0],
    'value': numberOfNodes1[0]
  });
  $('#multilevelCoarsener2').prop({
    'min': 1,
    'max': numberOfNodes1[1],
    'value': numberOfNodes1[1]
  });
  document.getElementById("output1").innerHTML = numberOfNodes1[0];
  document.getElementById("output2").innerHTML = numberOfNodes1[1];
}

from upload.js:

$.ajax({
  url: '/upload',
  type: 'POST',
  data: formData,
  processData: false,
  contentType: false,
  success: function(data){
      console.log('Upload successful!\n');
      /* Change slider min & max values */
      // changeMinAndMaxValues(data);
      /* Show slider's current value */
      showValue();
      /* Hide upload box */
      $('#uploadBox').css('display', 'none');
      /* Build the graph after loading .json file */
      build(data);
      /* Below won't work - AJAX call works for same page only! */
      // location.href = '/visualization';
  },
  xhr: loadGraph
  // xhr: function() {
  //   // create an XMLHttpRequest
  //   var xhr = new XMLHttpRequest();
  //
  //   // listen to the 'progress' event
  //   xhr.upload.addEventListener('progress', function(evt) {
  //
  //     if (evt.lengthComputable) {
  //       // calculate the percentage of upload completed
  //       var percentComplete = evt.loaded / evt.total;
  //       percentComplete = parseInt(percentComplete * 100);
  //
  //       // update the Bootstrap progress bar with the new percentage
  //       $('.progress-bar').text(percentComplete + '%');
  //       $('.progress-bar').width(percentComplete + '%');
  //
  //       // once the upload reaches 100%, set the progress bar text to done
  //       if (percentComplete === 100) {
  //         $('.progress-bar').html('Done');
  //       }
  //
  //     }
  //
  //   }, false);
  //
  //   return xhr;
  // }
});

from threeGraph.js:

/* Define depth variable to set camera positioning */
var depth = new Depth(0);
depth.setZ(Math.abs(graph.getMinNode()) + Math.abs(graph.getMaxNode()));
/* Create the camera and associate it with the scene */
if(camera !== undefined) delete camera;
camera = new THREE.PerspectiveCamera(120, canvasWidth / canvasHeight, 1, 2000);
camera.position.set(0, 0, 70);
// camera.position.set(0, 0, (depth.getZ()));
// console.log("(depth.getZ()): ", (depth.getZ()));
camera.lookAt(scene.position);
camera.name = "camera";
scene.add(camera);

from node.js:

/**
 * @constructor
 * @param {Object} circleGeometry A geometry of type circle (from three.js).
 * @param {Object} meshBasicMaterial Material for the geometry (from three.js).
 *
function Node(circleGeometry, meshBasicMaterial)
{
    this.circleGeometry = circleGeometry;
    this.meshBasicMaterial = meshBasicMaterial;
}*/

var Node = function(nodeObject, min, max, circleGeometry, meshBasicMaterial)
{
    min = ecmaStandard(min, 0);
    max = ecmaStandard(max, 10);
    circleGeometry = ecmaStandard(circleGeometry, undefined);
    meshBasicMaterial = ecmaStandard(meshBasicMaterial, undefined);
    try
    {
        this.nodeObject = nodeObject;
        if(this.nodeObject.weight == undefined)
        {
            this.nodeObject.weight = 1;
        }

        /* Use feature scaling to fit nodes */
        var x = (this.nodeObject.weight - min)/(max-min) + 1.5;
        // circleGeometry.scale(x, x, x);
        // this.circleGeometry = new THREE.CircleGeometry(x, 100);
        this.meshBasicMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.FrontSide, depthFunc: THREE.AlwaysDepth });

        /* Store number of nodes from each layer */

        // if(meshBasicMaterial == undefined)
        // {
        //     this.meshBasicMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.FrontSide, depthFunc: THREE.AlwaysDepth });
        // }
        // else
        // {
        //     this.meshBasicMaterial = meshBasicMaterial;
        // }
    }
    catch(err)
    {
        throw "Constructor must have nodeObject type as first parameter! " +
        " Constructor " +
            " params: " +
            "    - nodeObject: the node object taken from the JSON file; " +
            "    - min: min value to be used in feature scaling; " +
            "    - max: max value to be used in feature scaling; " +
            "    - circleGeometry: a geometry of type circle (from three.js); " +
            "    - meshBasicMaterial: material for geometry (from three.js).";
    }
    finally
    {
        this.circle = new THREE.Mesh(circleGeometry, this.meshBasicMaterial);
        this.circle.scale.set(x, x, x);
        this.circle.name = "" + this.nodeObject.id;
        this.circle.geometry.computeFaceNormals();
        this.circle.geometry.computeBoundingBox();
        this.circle.geometry.computeBoundingSphere();
        // this.circle.geometry.boundingBox = null;
        this.circle.geometry.verticesNeedUpdate = true;
        this.circle.renderOrder = 1;
    }
}

/**
 * Build a node into the scene, using a force directed layout
 */
Node.prototype.buildForceDirected = function()
{
    console.log("To be implemented");
}

// if(horizontal)
// {
//   /* Separate vertical lines according to number of layers */
//   if(index >= firstLayer)
//   {
//       var y = alpha;
//       // index = (Math.abs( firstLayer - lastLayer ) / 2) - firstLayer;
//       index = lastLayer;
//       // index = Math.round(index / lastLayer) + lastIndex;
//   }
//   else
//   {
//       var y = alpha * (-1);
//   }
//   x = index * theta;
//   this.circle.position.set(x, y, 0);
// }
// else if(!horizontal)
// {
//   /* Separate vertical lines according to number of layers */
//   if(index >= firstLayer)
//   {
//       var x = alpha;
//       // index = (Math.abs( firstLayer - lastLayer ) / 2) - firstLayer;
//       index = lastLayer;
//       // index = Math.round(index / lastLayer) + lastIndex;
//   }
//   else
//   {
//       var x = alpha * (-1);
//   }
//   y = index * theta;
//   this.circle.position.set(x, y, 0);
// }

from Edge.js:

var Edge = function(edgeObject, min, max, geometry, lineBasicMaterial)
{
    /* Pre ECMAScript 2015 standardization */
    // min = typeof min !== 'undefined' ? min : 0;
    // max = typeof max !== 'undefined' ? max : 50;
    min = ecmaStandard(min, 0);
    max = ecmaStandard(max, 100);
    // geometry = typeof geometry !== 'undefined' ? geometry : undefined;
    // lineBasicMaterial = typeof lineBasicMaterial !== 'undefined' ? lineBasicMaterial : undefined;
    try
    {
        this.edgeObject = edgeObject;
        /* Defining edge id by concatenation of source and target nodes' id */
        this.edgeObject.id = "e" + edgeObject.source.toString() + edgeObject.target.toString();
        if(this.edgeObject.weight == undefined)
        {
            this.edgeObject.weight = 1;
        }

        /* Use feature scaling to fit edges */
        this.edgeRadius = (this.edgeObject.weight - min)/(max-min);
        lineBasicMaterial = new THREE.LineBasicMaterial({linewidth: this.edgeRadius, color: 0x8D9091, side: THREE.DoubleSide});
        this.line = new THREE.LineSegments(geometry, lineBasicMaterial);
        this.line.name = "e" + this.edgeObject.source+this.edgeObject.target;
        this.line.boundingBox = null;
        this.line.renderOrder = 0;
        this.line.matrixAutoUpdate = false;
    }
    catch(err)
    {
        throw "Constructor must have edgeObject type as first parameter! " +
        " Constructor " +
            " params: " +
            "    - edgeObject: the edge object taken from the JSON file; " +
            "    - min: min value to be used in feature scaling; " +
            "    - max: max value to be used in feature scaling; " +
            "    - geometry: a generic geometry (from three.js); " +
            "    - lineBasicMaterial: line material for the object (from three.js).";
    }
    finally
    {
        // if(geometry != undefined && lineBasicMaterial == undefined)
        // {
        //     this.geometry = geometry;
        //     this.lineBasicMaterial = new THREE.LineBasicMaterial({linewidth: this.edgeRadius, color: 0x8D9091, side: THREE.DoubleSide});
        // }
        // else if(geometry == undefined && lineBasicMaterial != undefined)
        // {
        //     this.geometry = new THREE.Geometry();
        //     this.lineBasicMaterial = lineBasicMaterial;
        // }
        // else if(geometry != undefined && lineBasicMaterial != undefined)
        // {
        //     this.geometry = geometry;
        //     this.lineBasicMaterial = lineBasicMaterial;
        // }
        // else
        // {
        //     this.geometry = new THREE.Geometry();
        //     this.lineBasicMaterial = new THREE.LineBasicMaterial({linewidth: this.edgeRadius, color: 0x8D9091, side: THREE.DoubleSide});
        // }

        /* TODO - eliminates ray tracing completely */
        // this.geometry.computeBoundingSphere();
        // this.geometry.computeFaceNormals();
        // this.geometry.boundingBox = null;
        // this.geometry.verticesNeedUpdate = true;
        // this.geometry.computeLineDistances();
        // this.geometry.computeBoundingBox();
        // this.geometry.computeFlatVertexNormals();
        // this.geometry.computeLineDistances();
        // this.geometry.computeMorphNormals();
        // this.geometry.verticesNeedUpdate = true;
    }
}

/**
 * Getter for Geometry
 */
Edge.prototype.getGeometry = function()
{
    return this.geometry;
}

/**
 * Setter for Geometry
 */
Edge.prototype.setGeometry = function(geometry)
{
    this.geometry = geometry;
}

/**
 * Getter for lineBasicMaterial
 */
Edge.prototype.getlineBasicMaterial = function()
{
    return this.lineBasicMaterial;
}

/**
 * Setter for lineBasicMaterial
 */
Edge.prototype.setlineBasicMaterial = function(lineBasicMaterial)
{
    this.lineBasicMaterial = lineBasicMaterial;
}

/**
 * Getter for line
 */
Edge.prototype.getLine = function()
{
    return this.line;
}

/**
 * Setter for line
 */
Edge.prototype.setLine = function(line)
{
    this.line = line;
}

from graph.js:

/**
* Get nodes meshes
*/
Graph.prototype.getNodesMeshes = function()
{
   var meshes = [];
   for(var i = 0; i < this.nodes.length; i++)
   {
       meshes.push(this.nodes[i].getCircle());
   }
   return meshes;
}


from bipartiteGraph.js:

/**
 * Find edge index in array of vertices, given edge position.
 * @public
 * @param {Object} position (x,y,z) positions of an inciding edge.
 * @param {Array} vertexArray Array of vertexes.
 * @returns {int} Index of (x,y,z) in array of vertexes.
 */
BipartiteGraph.prototype.findEdgePositionIndex = function(position, vertexArray)
{
  for(var i = 0; i < vertexArray.length; i++)
  {
    if(vertexArray[i].x == position.x && vertexArray[i].y == position.y && vertexArray[i].z == position.z)
    {
      return i;
    }
  }
  /** If no matching element was found, return -1 */
  return -1;
  // /** Find all occurrences of x inside vertexArray */
  // var position1 = vertexArray.filter(function(obj){
  //   return obj.x == position.x;
  // });
  // /** Find all occurrences of x inside position1 */
  // var position2 = position1.filter(function(obj){
  //   return obj.y == position.y;
  // });
  // /** Find all occurrences of x inside position2 */
  // var position3 = position2.filter(function(obj){
  //   return obj.z == position.z;
  // });
  // /** Return position3 */
  // return position3;
}


from main.js:

var serverPort = 3030;
var express = require('express');
var app = express();
var path = require('path');
var formidable = require('formidable');
var fs = require('fs');
var bodyParser = require('body-parser');
var nodeCmd = require('node-cmd');
var fileName = "";
var graphSize = [];
var pyName = "";
var currentLevel = 0;


app.use(express.static(path.join(__dirname, 'public')));
app.use(express.static(path.join(__dirname, 'build')));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

app.set('views', __dirname+'/public/views');
// app.engine('html', require('ejs').renderFile);
app.set('view engine', 'html');

/**
 * @desc Add number of edges to .json string being created.
 * @public
 * @param {string} data - .json string.
 * @returns {string} .json string containing number of edges.
 */
function addNumberOfEdgesToJSON(data)
{
  var jason = JSON.parse(data);
  jason.graphInfo[0].edges = jason.links.length.toString();
  data = JSON.stringify(jason);
  return data;
}

/**
 * @desc Find and add maximum and minimum edge weights at edge set.
 * @param {string} data .json string containing graph data.
 * @returns {string} data .json string containing graph data.
 */
function addMinAndMaxEdge(data)
{
  var max = 1, min = 1000000000;
  var jason = JSON.parse(data);
  for(var i = 0; i < jason.links.length; i++)
  {
    /** Check if weight exists */
    if(parseInt(jason.links[i].weight) != undefined)
    {
      if(parseInt(jason.links[i].weight) > max)
      {
        max = parseInt(jason.links[i].weight);
      }
      if(parseInt(jason.links[i].weight) < min)
      {
        min = parseInt(jason.links[i].weight);
      }
    }
  }
  /** Store in .json edges weights */
  jason.graphInfo[0].maxEdgeWeight = parseInt(max);
  jason.graphInfo[0].minEdgeWeight = parseInt(min);
  return JSON.stringify(jason);
}

/**
 * @desc Find and add maximum and minimum node weights at node set.
 * @param {string} data .json string containing graph data.
 * @returns {string} data .json string containing graph data.
 */
function addMinAndMaxNode(data)
{
  var max = 1, min = 1000000000;
  var jason = JSON.parse(data);
  for(var i = 0; i < jason.nodes.length; i++)
  {
    /** Check if weight exists */
    if(parseInt(jason.nodes[i].weight) != undefined)
    {
      if(parseInt(jason.nodes[i].weight) > max)
      {
        max = parseInt(jason.nodes[i].weight);
      }
      if(parseInt(jason.nodes[i].weight) < min)
      {
        min = parseInt(jason.nodes[i].weight);
      }
    }
  }
  /** Store in .json nodes weights */
  jason.graphInfo[0].maxNodeWeight = max;
  jason.graphInfo[0].minNodeWeight = min;
  return JSON.stringify(jason);
}

/**
 * @desc Add necessary values for .json.
 * @param {string} data .json string containing graph data.
 * @returns {string} data .json string containing graph data.
 */
function addValues(data)
{
  return addMinAndMaxEdge(addMinAndMaxNode(addNumberOfEdgesToJSON(data)));
}

/**
 * Check to see which operating system version is being used, assigning either '/' or '\' for folder paths.
 * @public
 * @returns {string} either '\' or '/' symbol for folder paths.
 */
function addFolderPath()
{
  return process.platform == "win32" ? "\\" : "/";
}

/**
 * Read .json file stored on server-side, sending it to client side.
 * @public
 * @param {string} path Path string for fs variable to read.
 * @param {Object} fs FileSystem API module.
 * @param {Object} req header sent via HTTP from HTML page, from Express API module callback 'post'.
 * @param {Object} res header to be sent via HTTP for HTML page, from Express API module callback 'post'.
 * @returns {string} if any error occurs during file read, return it via console; otherwise return nothing.
 */
function readJsonFile(path, fs, req, res)
{
  fs.readFile(path, 'utf8', function(err, data){
    if(err)
    {
      return console.log(err);
    }
    else
    {
      /* Store graph size */
      if(graphSize.length == 0) JSON.parse(data).graphInfo[0].vlayer != undefined ? graphSize = JSON.parse(data).graphInfo[0].vlayer : graphSize = JSON.parse(data).graphInfo[0].vertices;
      /* Send data to client */
      res.end(JSON.stringify({graph: addValues(data), nLevels: currentLevel, graphName: path, firstSet: req.body.coarsening, secondSet: req.body.coarseningSecondSet}));
    }
  });
}

/**
 * Convert from .gml to .json notation, and adjust graph weights according to .cluster file.
 * @public
 * @param {string} hierarchicalPyName Current file name, according to level of coarsening.
 * @param {string} pyPath Path to folder containing .py files.
 * @param {Object} nodeCmd NodeCmd API module.
 * @param {string} folderChar Either '\' or '/' symbol for folder paths.
 * @param {string} pyName Multilevel paradigm program name.
 * @param {Object} fs FileSystem API module.
 * @param {Object} req header sent via HTTP from HTML page, from Express API module callback 'post'.
 * @param {Object} res header to be sent via HTTP for HTML page, from Express API module callback 'post'.
 * @returns {string} if any error occurs during file read, return it via console; otherwise return nothing.
 */
function convertAndAdjust(hierarchicalPyName, pyPath, nodeCmd, folderChar, pyName, fs, req, res)
{
  /* Execute .gml to .json conversion */
  console.log('python ' + pyPath + 'gmlToJson3.py uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + '.gml uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + ".json");
  nodeCmd.get('python ' + pyPath + 'gmlToJson3.py uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + '.gml uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + ".json", function(data, err, stderr) {
    if(!err)
    {
      // console.log("data from python script " + data);
      // console.log('python ' + pyPath + 'setWeights4.py -o uploads' + folderChar + fileName.split(".")[0] + folderChar + fileName.split(".")[0] + '.json -c uploads' + folderChar + fileName.split(".")[0] + folderChar +  hierarchicalPyName + '.json -g uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + '.cluster');
      /** Set weights properly using .cluster file generated from multilevel paradigm */
      console.log('python ' + pyPath + 'setWeights4.py -o uploads' + folderChar + fileName.split(".")[0] + folderChar + fileName.split(".")[0] + '.json -c uploads' + folderChar + fileName.split(".")[0] + folderChar +  hierarchicalPyName + '.json -g uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + '.cluster');
      nodeCmd.get('python ' + pyPath + 'setWeights4.py -o uploads' + folderChar + fileName.split(".")[0] + folderChar + fileName.split(".")[0] + '.json -c uploads' + folderChar + fileName.split(".")[0] + folderChar +  hierarchicalPyName + '.json -g uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + '.cluster', function(data, err, stderr) {
        if(!err)
        {
          // console.log("data from python script " + data);
          /** Rename new file to original coarsened file */
          console.log('mv uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + 'Weighted.json uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + '.json');
          nodeCmd.get('mv uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + 'Weighted.json uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + '.json', function(data, err, stderr) {
            if(!err)
            {
              readJsonFile('uploads' + folderChar + fileName.split(".")[0] + folderChar + hierarchicalPyName + '.json', fs, req, res);
            }
            else
            {
              console.log("bash script cmd error: " + err);
            }
          });
        }
        else
        {
          console.log("python script cmd error: " + err);
        }
      });
    }
    else
    {
      console.log("python script cmd error: " + err);
    }
  });
}

/**
 * Create a coarsened graph from initial graph, according to reduction factor given by user.
 * @public
 * @param {Object} nodeCmd NodeCmd API module.
 * @param {string} folderChar Either '\' or '/' symbol for folder paths.
 * @param {string} pyName Multilevel paradigm program name.
 * @param {string} pyCoarsening Reduction factor coarsening given by user.
 * @param {Object} fs FileSystem API module.
 * @param {Object} req header sent via HTTP from HTML page, from Express API module callback 'post'.
 * @param {Object} res header to be sent via HTTP for HTML page, from Express API module callback 'post'.
 * @returns {string} if any error occurs during file read, return it via console; otherwise return nothing.
 */
function createCoarsenedGraph(nodeCmd, folderChar, pyName, pyCoarsening, fs, req, res)
{
  /* Convert .json file to .ncol */
  nodeCmd.get('python mob' + folderChar + 'jsonToNcol.py --input uploads' + folderChar + fileName.split(".")[0] + folderChar + fileName.split(".")[0] + '.json --output uploads' + folderChar + fileName.split(".")[0] + folderChar + fileName.split(".")[0] + '.ncol', function(data, err, stderr) {
    if(!err)
    {
      // console.log("data from python script " + data);
      /* Build python parameters string */
      var pyPath = "mob" + folderChar;
      var pyProg = "coarsening.py";
      var pyParams = "-f uploads" + folderChar + fileName.split(".")[0] + folderChar + fileName.split(".")[0] + ".ncol -d uploads" + folderChar + fileName.split(".")[0] + folderChar + " -o " + pyName + " -v " + parseInt(graphSize.split(" ")[0]) + " " + parseInt(graphSize.split(" ")[1]) + " " + pyCoarsening + " -e gml" ;
      if(req.body.coarsening == 0 || req.body.coarseningSecondSet == 0)
      {
        req.body.firstSet == 1 ? pyParams = pyParams + " -l 0 -m " + req.body.nLevels + " 0 " : pyParams = pyParams + " -l 1 -m 0 " + req.body.nLevels;
      }
      else
      {
        // pyParams = pyParams + " -m 1 1 ";
        // pyParams = pyParams + " -m " + req.body.coarsening*10 + " " + req.body.coarseningSecondSet*10 + " ";
        pyParams = pyParams + " -m " + req.body.nLevels + " " + req.body.nLevels + " ";
      }
      /** Execute python scripts */
      /** Execute coarsening with a given reduction factor */
      console.log('python ' + pyPath + pyProg + " " + pyParams);
      nodeCmd.get('python ' + pyPath + pyProg + " " + pyParams, function(data, err, stderr) {
        if (!err)
        {
          // console.log("data from python script " + data);
          // if(req.body.nLevels !== undefined) pyName = pyName + "n" + req.body.nLevels;
          console.log("pyName:");
          console.log(pyName);
          for(var i = 0; req.body.nLevels !== undefined && i < req.body.nLevels; i++)
          {
            var hierarchicalPyName = pyName + "n" + (i+1).toString();
            console.log("hierarchicalPyName:");
            console.log(hierarchicalPyName);
            convertAndAdjust(hierarchicalPyName, pyPath, nodeCmd, folderChar, pyName, pyCoarsening, fs, req, res);
            currentLevel = i+1;
          }
        }
        else
        {
          console.log("python script cmd error: " + err);
        }
      });
    }
    else
    {
      console.log("python script cmd error: " + err);
    }
  });
}

/**
 * Server-side callback function from 'express' framework for incoming graph. Create a local folder with same name as file, to store future coarsened graphs.
 * @public @callback
 * @param {Object} req header incoming from HTTP;
 * @param {Object} res header to be sent via HTTP for HTML page.
 */
app.post('/upload', function(req, res) {
  graphSize = [];
  currentLevel = 0;
  var folderChar = addFolderPath();
  /* Create an incoming form object */
  var form = new formidable.IncomingForm();
  /* Specify that we want to allow the user to upload multiple files in a single request */
  form.multiples = true;
  /* Store all uploads in the /uploads directory */
  form.uploadDir = path.join(__dirname, '/uploads');
  /** Every time a file has been uploaded successfully, rename it to it's orignal name */
  form.on('file', function(field, file) {
    fs.rename(file.path, path.join(form.uploadDir, file.name), function(){return;});
    /** Creates directory for uploaded graph */
    nodeCmd.get('mkdir -p uploads' + folderChar + file.name.split(".")[0] + folderChar, function(data, err, stderr) {
      if (!err)
      {
        // console.log("data from python script " + data);
        /* Assign global variable with file name for later coarsening */
        fileName = file.name;
        /* Transforms .gml file into .json extension file if file is .gml */
        if(file.name.split(".")[1] === "gml")
        {
          /** Convert to .json and move it to upload folder with same name */
          nodeCmd.get('python mob' + folderChar + 'gmlToJson3.py uploads' + folderChar + file.name + ' uploads' + folderChar + file.name.split(".")[0] + folderChar + file.name.split(".")[0] + '.json', function(data, err, stderr) {
                            if (!err)
                            {
                              /** Python script executed successfully; read .json file */
                              readJsonFile(form.uploadDir + folderChar + file.name.split(".")[0] + folderChar + file.name.split(".")[0] + '.json', fs, req, res);
                            }
                            else
                            {
                                console.log("python script cmd error: " + err);
                            }
                          });
        }
          else if(file.name.split(".")[1] === "json")
          {
            /** Copy .json file to upload folder with same name */
            nodeCmd.get('cp uploads' + folderChar + file.name + ' uploads' + folderChar + file.name.split(".")[0] + folderChar + file.name, function(data, err, stderr){
              /** Python script executed successfully; read .json file */
                if(!err)
                {
                  readJsonFile(form.uploadDir + folderChar + file.name.split(".")[0] + folderChar + file.name.split(".")[0] + '.json', fs, req, res);
                }
                else
                {
                  console.log("python script cmd error: " + err);
                }
            });
          }
      }
        else
        {
          console.log("python script cmd error: " + err);
        }
    });
  });

  /* Log any errors that occur */
  form.on('error', function(err) {
    console.log('An error has occured: \n' + err);
  });

  /* Parse incoming request containing form data */
  form.parse(req, function(err, fields, files) {
  });
});

/**
 * Server-side callback function from 'express' framework for slide route. Get reduction factor from multilevel paradigm, execute multilevel, get new graph and send it to client.
 * @public @callback
 * @param {Object} req header incoming from HTTP;
 * @param {Object} res header to be sent via HTTP for HTML page.
 */
// app.post('/slide', function(req, res) {
app.post('/coarse', function(req, res) {
  var folderChar = addFolderPath();
  /** Test if no coarsening has been applied to both sets; if such case is true, return original graph */
  if(req.body.coarsening == "0" && req.body.coarseningSecondSet == "0")
  {
    readJsonFile('uploads' + folderChar + fileName.split(".")[0] + folderChar + fileName.split(".")[0] + '.json', fs, req, res);
  }
  else
  {
    /* Changing file name according to graph name */
    pyName = fileName.split(".")[0] + "Coarsened" + "l" + req.body.coarsening.split(".").join("") + "r" + req.body.coarseningSecondSet.split(".").join("");
    // if(req.body.nLevels !== undefined) pyName = pyName + "n" + req.body.nLevels;
    var pyCoarsening = "-r " + req.body.coarsening + " " + req.body.coarseningSecondSet;
    if(req.body.nLevels !== undefined && req.body.nLevels != 0) pyCoarsening = pyCoarsening + " --save_hierarchy ";
    /** Check if coarsened file already exists; if not, generate a new coarsened file */
    fs.readFile('uploads' + folderChar + fileName.split(".")[0] + folderChar + pyName + '.json', 'utf8', function(err, data) {
      if(err) /* File doesn't exist */
      {
        createCoarsenedGraph(nodeCmd, folderChar, pyName, pyCoarsening, fs, req, res);
      }
      else /* File exists*/
      {
        /* Send data to client */
        res.end(addValues(data));
      }
    });
  }

  // console.log(req);
  // console.log("graphSize: ");
  // console.log(graphSize);
});

/**
 * Server-side callback function from 'express' framework for switch route. Changes bipartite graph layout, from horizontal to vertical and vice-versa.
 * @public @callback
 * @param {Object} req header incoming from HTTP;
 * @param {Object} res header to be sent via HTTP for HTML page.
 */
app.post('/switch', function(req, res){
  var folderChar = addFolderPath();
  // readJsonFile('uploads' + folderChar + fileName.split(".")[0] + folderChar + fileName.split(".")[0] + '.json', fs, res);
  readJsonFile('uploads' + folderChar + fileName.split(".")[0] + folderChar + pyName + "n" + currentLevel + '.json', fs, req, res);
});

/**
 * Server-side callback function from 'express' framework for get levels route. Gets different graph levels, in case number of levels is different than 1.
 * @public @callback
 * @param {Object} req header incoming from HTTP;
 * @param {Object} res header to be sent via HTTP for HTML page.
 */
app.post('/getLevels', function(req, res){
  /** From https://stackoverflow.com/questions/43669913/node-js-how-to-inspect-request-data */
  req.on('data', function(chunk) {
        var bodydata = chunk.toString('utf8');
        // console.log(bodydata);
        readJsonFile(bodydata, fs, req, res);
    });
});

/**
 * Server-side callback function from 'express' framework for main route.
 * @public @callback
 * @param {Object} req header incoming from HTTP;
 * @param {Object} res header to be sent via HTTP for HTML page.
 */
app.get('/', function(req, res){
  res.sendFile(path.join(__dirname, 'views/index.html'));
});

/** Main function to trigger server */
var server = app.listen(serverPort, function(){
  console.log('Server listening on port ' + serverPort);
});

from eventHandler.js, method "showParents":
// var layScope = this;
// $.ajax({
//   url: '/getSorted',
//   type: 'POST',
//   data: { name: previousMesh.name, pred: predecessors[i] },
//   success: function(data){
//     predecessors[i] = parseInt(data);
//     if(predecessors[i] != -1)
//     {
//       var layers = JSON.parse(previousMesh.geometry.faces[(parseInt(predecessors[i]))].layers);
//       /** First layer isn't rendered; update predecessor ids so that it searches for proper parents */
//       if(layers.renderFirstLayer == false && layers.renderLastLayer == true)
//       {
//         predecessors[i] = predecessors[i] - (parseInt(previousMesh.geometry.faces[(parseInt(predecessors[i]))].firstLayer)*32);
//       }
//       if(previousMesh.geometry.faces[(parseInt(predecessors[i]))] !== undefined)
//       {
//         /** Color predecessors */
//         var targetPos = previousMesh.geometry.faces[(parseInt(predecessors[i]))].position;
//         /** Check if predecessor vertexes were rendered */
//         if(layScope.wasRendered(sourcePos, targetPos, layout))
//         {
//           layScope.neighbors.push({vertexInfo: parseInt(predecessors[i]), mesh: previousMesh.name});
//           var v2 = new THREE.Vector3(targetPos.x, targetPos.y, targetPos.z);
//           for(var j = 0; j < 32; j++)
//           {
//             previousMesh.geometry.faces[(parseInt(predecessors[i])) + j].color.setRGB(1.0, 0.0, 0.0);
//           }
//           edgeGeometry.vertices.push(v1);
//           edgeGeometry.vertices.push(v2);
//         }
//       }
//     }
//   },
//   xhr: loadGraph
// });

from eventHandler.js:

/**
 * Show merged vertexes which formed super vertex clicked.
 * @param {Object} intersection Intersected object in specified scene.
 * @param {Object} scene Scene for raycaster.
 * @param {int} layout Graph layout.
 */
EventHandler.prototype.showParents = function(intersection, scene, layout)
{
  if(intersection !== undefined)
  {
    this.clicked.wasClicked = true;
    /** Get meshes */
    var previousMeshNumber = parseInt(intersection.object.name[intersection.object.name.length-1]) + 1;
    var originalMeshName = intersection.object.name.substring(0, intersection.object.name.length-1);
    if(isNaN(previousMeshNumber)) previousMeshNumber = "h1";
    // var currentMesh = scene.getObjectByName(intersection.object.name);
    var previousMesh = scene.getObjectByName(originalMeshName + previousMeshNumber.toString());
    if(previousMesh != undefined)
    {
      /** Get array of predecessors */
      var startFace = intersection.faceIndex-(intersection.face.a-intersection.face.c)+1;
      var properties = JSON.parse(intersection.object.geometry.faces[startFace].properties);
      // console.log("intersection.object.geometry.faces[startFace].position:");
      // console.log(intersection.object.geometry.faces[startFace].position);
      var edgeGeometry = new THREE.Geometry();
      var sourcePos = intersection.object.geometry.faces[startFace].position;
      var v1 = new THREE.Vector3(sourcePos.x, sourcePos.y, sourcePos.z);
      /** Color vertexes */
      for(var j = 0; j < 32; j++)
      {
        intersection.object.geometry.faces[startFace+j].color.setRGB(1.0, 0.0, 0.0);
      }
      intersection.object.geometry.colorsNeedUpdate = true;
      this.neighbors.push({vertexInfo: parseInt(JSON.parse(intersection.object.geometry.faces[startFace].properties).id)*32, mesh: intersection.object.name});
      var predecessors;
      /** Color predecessors */
      for(pred in properties)
      {
        if(pred == "predecessor")
        {
          predecessors = properties[pred].split(",");
          // for(var i = 0; i < predecessors.length; i++)
          // {
          //   predecessors[i] = parseInt(predecessors[i]*32);
          //   var layers = JSON.parse(previousMesh.geometry.faces[(parseInt(predecessors[i]))].layers);
          //   /** First layer isn't rendered; update predecessor ids so that it searches for proper parents */
          //   if(layers.renderFirstLayer == false && layers.renderLastLayer == true)
          //   {
          //     predecessors[i] = predecessors[i] - (parseInt(previousMesh.geometry.faces[(parseInt(predecessors[i]))].firstLayer)*32);
          //   }
          //   if(previousMesh.geometry.faces[(parseInt(predecessors[i]))] !== undefined)
          //   {
          //     /** Color predecessors */
          //     var targetPos = previousMesh.geometry.faces[(parseInt(predecessors[i]))].position;
          //     /** Check if predecessor vertexes were rendered */
          //     if(this.wasRendered(sourcePos, targetPos, layout))
          //     {
          //       this.neighbors.push({vertexInfo: parseInt(predecessors[i]), mesh: previousMesh.name});
          //       var v2 = new THREE.Vector3(targetPos.x, targetPos.y, targetPos.z);
          //       for(var j = 0; j < 32; j++)
          //       {
          //         previousMesh.geometry.faces[(parseInt(predecessors[i])) + j].color.setRGB(1.0, 0.0, 0.0);
          //       }
          //       edgeGeometry.vertices.push(v1);
          //       edgeGeometry.vertices.push(v2);
          //     }
          //   }
          // }
        }
      }
      var layScope = this;
      $.ajax({
        url: '/getSorted',
        type: 'POST',
        data: { name: previousMesh.name, pred: predecessors },
        success: function(data){
          data = JSON.parse(data);
          for(var i = 0; i < data.array.length; i++)
          {
            data.array[i] = parseInt(data.array[i])*32;
            var layers = JSON.parse(previousMesh.geometry.faces[(parseInt(data.array[i]))].layers);
            /** First layer isn't rendered; update predecessor ids so that it searches for proper parents */
            if(layers.renderFirstLayer == false && layers.renderLastLayer == true)
            {
              data.array[i] = data.array[i] - (parseInt(previousMesh.geometry.faces[(parseInt(data.array[i]))].firstLayer)*32);
            }
            if(previousMesh.geometry.faces[(parseInt(data.array[i]))] !== undefined)
            {
              /** Color predecessors */
              var targetPos = previousMesh.geometry.faces[(parseInt(data.array[i]))].position;
              /** Check if predecessor vertexes were rendered */
              if(layScope.wasRendered(sourcePos, targetPos, layout))
              {
                layScope.neighbors.push({vertexInfo: parseInt(data.array[i]), mesh: previousMesh.name});
                var v2 = new THREE.Vector3(targetPos.x, targetPos.y, targetPos.z);
                for(var j = 0; j < 32; j++)
                {
                  previousMesh.geometry.faces[(parseInt(data.array[i])) + j].color.setRGB(1.0, 0.0, 0.0);
                }
                edgeGeometry.vertices.push(v1);
                edgeGeometry.vertices.push(v2);
              }
            }
          }
          previousMesh.geometry.colorsNeedUpdate = true;
          for(var i = 0; i < edgeGeometry.vertices.length; i = i + 2)
          {
            edgeGeometry.colors[i] = new THREE.Color("rgb(255, 0, 0)");
            edgeGeometry.colors[i+1] = edgeGeometry.colors[i];
          }
          edgeGeometry.colorsNeedUpdate = true;

          /** Create one LineSegments and add it to scene */
          var edgeMaterial = new THREE.LineBasicMaterial({vertexColors:  THREE.VertexColors});
          var lineSegments = new THREE.LineSegments(edgeGeometry, edgeMaterial, THREE.LinePieces);
          lineSegments.name = "parentConnections";
          scene.add(lineSegments);

          edgeGeometry.dispose();
          edgeGeometry = null;
          edgeMaterial.dispose();
          edgeMaterial = null;
        },
        xhr: loadGraph
      });
    }
    /** Recursively highlight parents */
    // if(previousMeshNumber != 'h1')
    //
    // else
    //   this.clicked.wasClicked = true;

  }
  else
  {
    this.clicked.wasClicked = false;
    scene.remove(scene.getObjectByName("parentConnections"));
    for(var i = 0; i < this.neighbors.length; i++)
    {
      var mesh = scene.getObjectByName(this.neighbors[i].mesh);
      for(var j = 0; j < 32; j++)
      {
        if(mesh.geometry.faces[(this.neighbors[i].vertexInfo*32)+j] !== undefined)
        {
            mesh.geometry.faces[(this.neighbors[i].vertexInfo*32)+j].color.setRGB(0.0, 0.0, 0.0);
        }
        else
        {
          mesh.geometry.faces[(this.neighbors[i].vertexInfo)+j].color.setRGB(0.0, 0.0, 0.0);
        }
        mesh.geometry.colorsNeedUpdate = true;
      }
    }
    /** Clearing array of neighbors */
    this.neighbors = [];
  }
}
